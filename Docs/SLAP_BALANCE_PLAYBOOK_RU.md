# SLAP Balance Playbook (8 направлений)

Версия слепка: текущее состояние проекта `SLAP` на момент этого документа.
Цель: сохранять одинаково честные ощущения удара для любых персонажей, даже при разных моделях/ригах/анимациях.

## 1) Что уже настроено сейчас (фиксируем как эталон процесса, не как вечные цифры)

### 1.1 Скрипт и компоненты, которые обязаны быть
- На персонаже должен быть `Animator`.
- На персонаже должен быть `SlapMechanics` (`Assets/Script/SlapMechanics.cs`).
- Для отладки (необязательно для релиза) есть `SlapDebugNumbers` (`Assets/Script/SlapDebugNumbers.cs`).
- В сцене `SampleScene` у атакующего используется контроллер `Assets/Animation/Akiro.controller`.

### 1.2 8 направлений (имена состояний)
- Диагонали:
1. `Slap1_Windup` -> `Slap1_Slap`
2. `Slap3_Windup` -> `Slap3_Slap`
3. `Slap7_Windup` -> `Slap7_Slap`
4. `Slap9_Windup` -> `Slap9_Slap`
- Кардинальные:
5. `SlapLeft_Windup` -> `SlapLeft_Slap`
6. `SlapRight_Windup` -> `SlapRight_Slap`
7. `SlapUp_Windup` -> `SlapUp_Slap`
8. `SlaperCut_Windup` -> `SlaperCut_Slap`

### 1.3 Что влияет на ввод и баланс (по факту работы)
- Deadzone: `max(swipeDeadzonePx, 2px, Screen.dpi * 0.02)`.
- Длина замаха в пикселях: `requiredPixels = swipeDistanceCm * dpi/2.54`.
- Замах накапливается по направлению свайпа + небольшая примесь скорости (`speedWeightInWindup`).
- Удар разрешён только если `effectiveWindup >= minWindupForSlap`.
- Удар запускается при реверсе по направлению:
1. либо по геометрии (`reverseDistance >= requiredPixels / slapReverseDistanceFactor`),
2. либо по накопленному обратному пути `reverseAccumulatedPx` (чтобы ловить быстрый флик/релиз).
- При отпускании пальца финальный дельта-кадр тоже учитывается для старта удара.

### 1.4 Важные текущие численные опоры (активные в сцене и/или дефолты скрипта)
- В сцене (`SampleScene`) уже сохранены:
1. `slapWindowSeconds = 0.5`
2. `swipeDistanceCm = 2.5`
3. `windupThreshold = 0.5`
4. `minWindupForSlap = 0.5`
5. `releaseDuration = 0.25`
6. `slapSpeedMin = 0.2`
7. `slapSpeedMax = 10.5`
8. `speedMinCmPerSec = 2`
9. `speedMaxCmPerSec = 120`
10. `speedWeightInWindup = 0.2`
- В скрипте дефолтом (если не переопределено сценой):
1. `minSlapPowerPercent = 5`
2. `minPlayableSlapSpeed = 0.05`
3. `fastSwipeSpeedBoost = 8`
4. `diagonalSlapSpeedMultiplier = 1`
5. `sideSlapSpeedMultiplier = 1`
6. `upSlapSpeedMultiplier = 1`
7. `uppercutSlapSpeedMultiplier = 1`
8. `sideSlapMinPlayableSpeed = 0.05`
9. `uppercutSlapMinPlayableSpeed = 0.05`
10. `sideUppercutSlapStartMaxNormalizedTime = 0.35`
11. `upSlapStartNormalizedTime = 0.35`
12. `useDirectHandTimeForCardinalSlaps = true`
13. `cardinalSlapCrossfadeSeconds = 0`, `upSlapCrossfadeSeconds = 0`, `slapStateCrossfadeSeconds = 0.06`

### 1.5 Что сейчас различается между направлениями
- По старту внутри slap-клипа:
1. `SlapUp_Slap`: старт фиксированный (`upSlapStartNormalizedTime`).
2. `SlapLeft/Right/SlaperCut`: старт ограничен сверху `sideUppercutSlapStartMaxNormalizedTime`, чтобы не стартовать “слишком поздно” (иначе визуально “сверхбыстро”).
3. Диагонали `Slap1/3/7/9`: старт через `1 - hand` (обратная привязка к высоте замаха), это даёт другой тайминг при одинаковом ощущении.
- По базовой скорости state в самом Animator (`Akiro.controller`):
1. `SlapLeft_Slap`: `m_Speed = 0.3`
2. `SlapRight_Slap`: `m_Speed = 0.3`
3. `SlaperCut_Slap`: `m_Speed = 0.3`
4. Диагонали и `SlapUp_Slap`: `m_Speed = 1`

Это не “кривые цифры”. Это компенсация разных клипов (амплитуда, длина дуги, темп ключей), чтобы итоговое ощущение было ближе к единому.

## 2) Ключевая философия баланса (самое важное)

Нельзя выравнивать значения “под линейку”.
Нужно выравнивать:
1. время до контакта,
2. читаемость замаха,
3. ощущение массы удара,
4. скорость возврата в idle,
5. шанс срабатывания удара при реальном пальцевом флике.

Если у двух направлений разные анимации, одинаковые числа почти всегда дадут разный геймплей.
Поэтому симметрия должна быть по ощущениям, а не по цифрам.

## 3) Что можно менять, что нельзя

### 3.1 Можно менять безопасно (по одному блоку за раз)
- Блок ввода:
1. `swipeDistanceCm`
2. `slapReverseDistanceFactor`
3. `speedMinCmPerSec/speedMaxCmPerSec`
4. `fastSwipeSpeedBoost`
- Блок “старт внутри клипа”:
1. `upSlapStartNormalizedTime`
2. `sideUppercutSlapStartMaxNormalizedTime`
3. `cardinalSlapStartOffset`
4. `diagonalSlapStartOffset`
- Блок state-speed в контроллере:
1. `m_Speed` конкретных slap-state
- Блок возврата:
1. `releaseDuration`

### 3.2 Нельзя трогать без полного цикла верификации 8 направлений
- Логику разрешения удара:
1. `effectiveWindup < minWindupForSlap`
2. проверку реверса (геометрия + накопление)
3. учёт финального кадра на отпускании
- Названия state/param:
1. `Hand_L_Move`
2. `Slap_Speed`
3. названия `Slap*_Windup/Slap*_Slap`
- Условия выхода slap-state в Animator (Exit Time), если не понимаешь эффект на весь цикл.

### 3.3 Что должно масштабироваться вместе
- Если увеличил `swipeDistanceCm`, обычно надо:
1. немного увеличить `releaseDuration` (иначе возврат кажется “нервным”),
2. проверить `slapReverseDistanceFactor` (иначе реверс станет слишком “дорогим”).
- Если поднял `fastSwipeSpeedBoost`, обязательно проверить:
1. что `SlapLeft/Right/Uppercut` не улетают в “мгновенный хлыст”,
2. что старт `sideUppercutSlapStartMaxNormalizedTime` не слишком поздний.
- Если меняешь `speedMaxCmPerSec`, обязательно перепроверять цифры силы и визуальную скорость одновременно.

## 4) Протокол переноса механики на новую модель/риг/анимации

Делай строго по шагам, не перескакивай.

### Шаг 1. Подготовка ассетов
- Проверить у всех 8 slap-клипов:
1. `loopTime = 0`
2. корректный импорт масштаба/аватара
3. совпадение имен state с кодом

### Шаг 2. Подключение Animator
- В контроллере должны существовать все 8 windup + 8 slap-state.
- Для всех slap-state включить `m_SpeedParameterActive = 1` и `m_SpeedParameter = Slap_Speed`.
- Проверить, что переход из slap-state в idle идёт по Exit Time, без случайных условий, обрывающих клип слишком рано.

### Шаг 3. Базовая настройка ввода (общая для всех направлений)
- Настроить:
1. `swipeDistanceCm`
2. `slapReverseDistanceFactor`
3. `minWindupForSlap`
4. `speedMinCmPerSec/speedMaxCmPerSec`
5. `fastSwipeSpeedBoost`
- Проверить deadzone на реальном девайсе (высокий DPI и низкий DPI).

### Шаг 4. Калибровка по направлениям (самое важное)
- Сначала эталон: диагонали `Slap1/3/7/9`.
- Затем подгонять `Left/Right/Up/Uppercut` только компенсаторами:
1. `m_Speed` в state,
2. лимиты старта (`upSlapStartNormalizedTime`, `sideUppercutSlapStartMaxNormalizedTime`),
3. при необходимости направленные множители (только если state-speed недостаточно).

### Шаг 5. Проверка “честности ощущения”
- Для каждого из 8 направлений провести минимум 30 повторов:
1. медленный замах + медленный реверс,
2. полный замах + средний реверс,
3. полный замах + быстрый флик,
4. частичный замах чуть выше порога,
5. частичный замах ниже порога (удар не должен сработать).
- Фиксировать:
1. время до контакта,
2. срабатывание/несрабатывание,
3. визуальную читаемость,
4. субъективную “массу”.

### Шаг 6. Финальная защита от перекоса персонажей
- Для каждого персонажа (разные риги/длины рук):
1. повторить шаг 5,
2. сравнить медианы времени до контакта по 8 направлениям,
3. сравнить процент успешных ударов на одинаковых шаблонах ввода,
4. сравнить амплитуду смещения ладони в мире (не должна давать скрытый reach advantage).

Если один персонаж стабильно “достаёт дальше/быстрее” при одинаковом вводе, компенсировать:
1. сначала стартовым normalized time,
2. потом state-speed,
3. и только потом глобальными входными порогами.

## 5) Турнирный протокол (анти-чит по анимации/ригу)

Перед турниром для каждого бойца:
1. Проверить один и тот же скрипт `SlapMechanics` без кастомных форков.
2. Проверить одинаковые глобальные input-параметры (deadzone, swipeDistance, windup threshold).
3. Проверить наличие всех 8 состояний и корректный `Slap_Speed` parameter binding.
4. Прогнать автоматический сценарий одинаковых свайпов (запись/реплей).
5. Зафиксировать метрики:
- среднее время до контакта на 8 направлениях,
- дисперсия,
- доля фейлов/ложных срабатываний,
- recovery time до idle.
6. Установить допуск (например, не более X% отклонения от эталона по каждому направлению).
7. Если допуск превышен, править только компенсаторы направления, не трогая базовую механику.

## 6) “Памятка от дурака” (очень коротко)

Если “вдруг сломалось”:
1. Не трогай всё сразу.
2. Проверь, что удар вообще стартует в правильном state.
3. Проверь `slapStart` (не поздний ли старт в клипе).
4. Проверь `Slap_Speed` реально ли подаётся в state.
5. Проверь Exit Time у slap-state.
6. Только потом крути цифры.

Если хочется “сделать всё одинаковым”:
1. Нельзя.
2. Разные клипы требуют разных компенсаций.
3. Равные цифры = неравный бой.

## 7) Что считать “идеально”

Идеально, это когда:
1. все 8 направлений читаются одинаково честно,
2. быстрый ввод ощущается быстрее, медленный медленнее,
3. частичный замах работает предсказуемо,
4. нет телепортов и рывков,
5. разные персонажи не получают скрытого бонуса от рига/анимации.

Если это соблюдено, баланс корректный, даже если цифры между направлениями разные.

